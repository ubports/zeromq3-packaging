Description: never use hard-coded local port numbers in tests
 The testsuite success should not depend on particular local port numbers
 being available for binding to.  Use wildcards throughout the test suite
 for local ports, and retrieve the real port number via ZMQ_LAST_ENDPOINT
 as necessary.
Author: Steve Langasek <steve.langasek@ubuntu.com>

Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_immediate.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_immediate.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_immediate.cpp
@@ -35,6 +35,9 @@ int main (void)
     int val;
     int rc;
     char buffer[16];
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     // TEST 1. 
     // First we're going to attempt to send messages to two
     // pipes, one connected, the other not. We should see
@@ -51,7 +54,9 @@ int main (void)
     val = 0;
     rc = zmq_setsockopt(to, ZMQ_LINGER, &val, sizeof(val));
     assert (rc == 0);
-    rc = zmq_bind (to, "tcp://127.0.0.1:6555");
+    rc = zmq_bind (to, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (to, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     // Create a socket pushing to two endpoints - only 1 message should arrive.
@@ -61,10 +66,12 @@ int main (void)
     val = 0;
     zmq_setsockopt (from, ZMQ_LINGER, &val, sizeof (val));
     // This pipe will not connect
+    // XXX: or will it?  Who guarantees that there's not a zmq running on this
+    // port?
     rc = zmq_connect (from, "tcp://localhost:5556");
     assert (rc == 0);
     // This pipe will 
-    rc = zmq_connect (from, "tcp://localhost:6555");
+    rc = zmq_connect (from, my_endpoint);
     assert (rc == 0);
 
     msleep (SETTLE_TIME);
@@ -112,7 +119,10 @@ int main (void)
     // Bind the valid socket
     to = zmq_socket (context, ZMQ_PULL);
     assert (to);
-    rc = zmq_bind (to, "tcp://127.0.0.1:5560");
+    rc = zmq_bind (to, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (to, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     val = 0;
@@ -136,7 +146,7 @@ int main (void)
     rc = zmq_connect (from, "tcp://localhost:5561");
     assert (rc == 0);
     // Connect to the valid socket
-    rc = zmq_connect (from, "tcp://localhost:5560");
+    rc = zmq_connect (from, my_endpoint);
     assert (rc == 0);
 
     // Send 10 messages, all should be routed to the connected pipe
@@ -186,9 +196,12 @@ int main (void)
     int on = 1;
     rc = zmq_setsockopt (frontend, ZMQ_IMMEDIATE, &on, sizeof (on));
     assert (rc == 0);
-    rc = zmq_bind (backend, "tcp://127.0.0.1:5560");
+    rc = zmq_bind (backend, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (backend, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
-    rc = zmq_connect (frontend, "tcp://localhost:5560");
+    rc = zmq_connect (frontend, my_endpoint);
     assert (rc == 0);
 
     //  Ping backend to frontend so we know when the connection is up
@@ -216,7 +229,7 @@ int main (void)
     assert (backend);
     rc = zmq_setsockopt (backend, ZMQ_LINGER, &zero, sizeof (zero));
     assert (rc == 0);
-    rc = zmq_bind (backend, "tcp://127.0.0.1:5560");
+    rc = zmq_bind (backend, my_endpoint);
     assert (rc == 0);
 
     //  Ping backend to frontend so we know when the connection is up
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_srcfd.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_srcfd.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_srcfd.cpp
@@ -43,6 +43,9 @@
 int main (void)
 {
     int rc;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     setup_test_environment();
     //  Create the infrastructure
@@ -54,10 +57,13 @@ int main (void)
     void *req = zmq_socket (ctx, ZMQ_REQ);
     assert (req);
 
-    rc = zmq_bind(rep, "tcp://127.0.0.1:5560");
+    rc = zmq_bind(rep, "tcp://127.0.0.1:*");
     assert (rc == 0);
 
-    rc = zmq_connect(req, "tcp://127.0.0.1:5560");
+    rc = zmq_getsockopt(rep, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+
+    rc = zmq_connect(req, my_endpoint);
     assert (rc == 0);
 
     char tmp[MSG_SIZE];
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_mandatory.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_router_mandatory.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_mandatory.cpp
@@ -32,12 +32,18 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     void *router = zmq_socket (ctx, ZMQ_ROUTER);
     assert (router);
 
-    int rc = zmq_bind (router, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (router, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     //  Send a message to an unknown peer with the default setting
@@ -60,7 +66,7 @@ int main (void)
     assert (dealer);
     rc = zmq_setsockopt (dealer, ZMQ_IDENTITY, "X", 1);
     assert (rc == 0);
-    rc = zmq_connect (dealer, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (dealer, my_endpoint);
     assert (rc == 0);
 
     //  Get message from dealer to know when connection is ready
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_handover.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_router_handover.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_handover.cpp
@@ -32,12 +32,18 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     void *router = zmq_socket (ctx, ZMQ_ROUTER);
     assert (router);
 
-    int rc = zmq_bind (router, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (router, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     // Enable the handover flag
@@ -50,7 +56,7 @@ int main (void)
     assert (dealer_one);
     rc = zmq_setsockopt (dealer_one, ZMQ_IDENTITY, "X", 1);
     assert (rc == 0);
-    rc = zmq_connect (dealer_one, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (dealer_one, my_endpoint);
     assert (rc == 0);
     
     //  Get message from dealer to know when connection is ready
@@ -68,7 +74,7 @@ int main (void)
     assert (dealer_two);
     rc = zmq_setsockopt (dealer_two, ZMQ_IDENTITY, "X", 1);
     assert (rc == 0);
-    rc = zmq_connect (dealer_two, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (dealer_two, my_endpoint);
     assert (rc == 0);
 
     //  Get message from dealer to know when connection is ready
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_probe_router.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_probe_router.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_probe_router.cpp
@@ -32,13 +32,18 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     
     //  Create server and bind to endpoint
     void *server = zmq_socket (ctx, ZMQ_ROUTER);
     assert (server);
-    int rc = zmq_bind (server, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     //  Create client and connect to server, doing a probe
@@ -49,7 +54,7 @@ int main (void)
     int probe = 1;
     rc = zmq_setsockopt (client, ZMQ_PROBE_ROUTER, &probe, sizeof (probe));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:5560");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
 
     //  We expect an identity=X + empty message from client
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_req_correlate.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_req_correlate.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_req_correlate.cpp
@@ -32,6 +32,9 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
@@ -49,10 +52,12 @@ int main (void)
     rc = zmq_setsockopt (req, ZMQ_RCVTIMEO, &rcvtimeo, sizeof (int));
     assert (rc == 0);
 
-    rc = zmq_connect (req, "tcp://localhost:5555");
+    rc = zmq_bind (router, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
-    rc = zmq_bind (router, "tcp://127.0.0.1:5555");
+    rc = zmq_connect (req, my_endpoint);
     assert (rc == 0);
 
     // Send a multi-part request.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_conflate.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_conflate.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_conflate.cpp
@@ -31,7 +31,10 @@
 
 int main (int, char *[])
 {
-    const char *bind_to = "tcp://127.0.0.1:5555";
+    const char *bind_to = "tcp://127.0.0.1:*";
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     int rc;
 
@@ -47,11 +50,13 @@ int main (int, char *[])
 
     rc = zmq_bind (s_in, bind_to);
     assert (rc == 0);
+    rc = zmq_getsockopt (s_in, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
 
     void* s_out = zmq_socket (ctx, ZMQ_PUSH);
     assert (s_out);
 
-    rc = zmq_connect (s_out, bind_to);
+    rc = zmq_connect (s_out, my_endpoint);
     assert (rc == 0);
 
     int message_count = 20;
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_issue_566.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_issue_566.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_issue_566.cpp
@@ -38,6 +38,9 @@ int main (void)
 {
     setup_test_environment();
     
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx1 = zmq_ctx_new ();
     assert (ctx1);
 
@@ -48,8 +51,10 @@ int main (void)
     int on = 1;
     int rc = zmq_setsockopt (router, ZMQ_ROUTER_MANDATORY, &on, sizeof (on));
     assert (rc == 0);
-    rc = zmq_bind (router, "tcp://127.0.0.1:5555");
+    rc = zmq_bind (router, "tcp://127.0.0.1:*");
     assert (rc != -1);
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
  
     //  Repeat often enough to be sure this works as it should
     for (int cycle = 0; cycle < 100; cycle++) {
@@ -63,7 +68,7 @@ int main (void)
         int rcvtimeo = 1000;
         rc = zmq_setsockopt (dealer, ZMQ_RCVTIMEO, &rcvtimeo, sizeof (int));
         assert (rc == 0);
-        rc = zmq_connect (dealer, "tcp://127.0.0.1:5555");
+        rc = zmq_connect (dealer, my_endpoint);
         assert (rc == 0);
 
         //  Router will try to send to dealer, at short intervals.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy_single_socket.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_proxy_single_socket.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy_single_socket.cpp
@@ -28,19 +28,38 @@
 */
 
 #include "testutil.hpp"
+#include <pthread.h>
 
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
+struct thread_data {
+    void *ctx;
+    char my_endpoint[MAX_SOCKET_STRING];
+    pthread_cond_t cond;
+    pthread_mutex_t mutex;
+};
+
 
 // This is our server task.
 // It runs a proxy with a single REP socket as both frontend and backend.
 
 void
-server_task (void *ctx)
+server_task (void *data)
 {
+    struct thread_data *tdata = (struct thread_data *)data;
+    void *ctx = tdata->ctx;
+    size_t len = MAX_SOCKET_STRING;
+
     void *rep = zmq_socket (ctx, ZMQ_REP);
     assert (rep);
-    int rc = zmq_bind (rep, "tcp://127.0.0.1:5563");
+    int rc = zmq_bind (rep, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (rep, ZMQ_LAST_ENDPOINT, tdata->my_endpoint, &len);
     assert (rc == 0);
+    pthread_mutex_lock(&tdata->mutex);
+    pthread_cond_signal(&tdata->cond);
+    pthread_mutex_unlock(&tdata->mutex);
 
     // Control socket receives terminate command from main over inproc
     void *control = zmq_socket (ctx, ZMQ_SUB);
@@ -68,21 +87,30 @@ int main (void)
 {
     setup_test_environment ();
 
+    struct thread_data tdata;
     void *ctx = zmq_ctx_new ();
     assert (ctx);
-    // client socket pings proxy over tcp
-    void *req = zmq_socket (ctx, ZMQ_REQ);
-    assert (req);
-    int rc = zmq_connect (req, "tcp://127.0.0.1:5563");
-    assert (rc == 0);
+    tdata.ctx = ctx;
+
+    pthread_cond_init(&tdata.cond, NULL);
+    pthread_mutex_init(&tdata.mutex, NULL);
+    pthread_mutex_lock(&tdata.mutex);
 
     // Control socket receives terminate command from main over inproc
     void *control = zmq_socket (ctx, ZMQ_PUB);
     assert (control);
-    rc = zmq_bind (control, "inproc://control");
+    int rc = zmq_bind (control, "inproc://control");
     assert (rc == 0);
 
-    void *server_thread = zmq_threadstart(&server_task, ctx);
+    void *server_thread = zmq_threadstart(&server_task, &tdata);
+
+    // client socket pings proxy over tcp
+    void *req = zmq_socket (ctx, ZMQ_REQ);
+    assert (req);
+
+    pthread_cond_wait(&tdata.cond, &tdata.mutex);
+    rc = zmq_connect (req, tdata.my_endpoint);
+    assert (rc == 0);
 
     char buf[255];
     rc = zmq_send(req, "msg1", 4, 0);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_dealer.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_spec_dealer.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_dealer.cpp
@@ -30,7 +30,8 @@
 #include "testutil.hpp"
 
 const char *bind_address = 0;
-const char *connect_address = 0;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 void test_round_robin_out (void *ctx)
 {
@@ -39,6 +40,9 @@ void test_round_robin_out (void *ctx)
 
     int rc = zmq_bind (dealer, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (dealer, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *rep [services];
@@ -91,6 +95,9 @@ void test_fair_queue_in (void *ctx)
 
     rc = zmq_bind (receiver, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (receiver, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *senders [services];
@@ -145,6 +152,9 @@ void test_destroy_queue_on_disconnect (v
 
     int rc = zmq_bind (A, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (A, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     void *B = zmq_socket (ctx, ZMQ_DEALER);
     assert (B);
@@ -227,12 +237,10 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
-    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:5555" };
-    const char *connects [] = { "inproc://a", "tcp://localhost:5555" };
+    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:*" };
 
     for (int transports = 0; transports < 2; ++transports) {
         bind_address = binds [transports];
-        connect_address = connects [transports];
 
         // SHALL route outgoing messages to available peers using a round-robin
         // strategy.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_router.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_spec_router.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_router.cpp
@@ -30,7 +30,8 @@
 #include "testutil.hpp"
 
 const char *bind_address = 0;
-const char *connect_address = 0;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 void test_fair_queue_in (void *ctx)
 {
@@ -43,6 +44,9 @@ void test_fair_queue_in (void *ctx)
 
     rc = zmq_bind (receiver, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (receiver, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *senders [services];
@@ -120,6 +124,9 @@ void test_destroy_queue_on_disconnect (v
 
     rc = zmq_bind (A, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (A, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     void *B = zmq_socket (ctx, ZMQ_DEALER);
     assert (B);
@@ -188,12 +195,10 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
-    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:5555" };
-    const char *connects [] = { "inproc://a", "tcp://localhost:5555" };
+    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:*" };
 
     for (int transport = 0; transport < 2; ++transport) {
         bind_address = binds [transport];
-        connect_address = connects [transport];
 
         // SHALL receive incoming messages from its peers using a fair-queuing
         // strategy.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_unbind_wildcard.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_unbind_wildcard.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_unbind_wildcard.cpp
@@ -26,13 +26,22 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
+    void *sb;
+    void *sc;
+    int rc;
+    char endpoint[256];
+    size_t endpoint_len;
+
+/* Disable all tests that don't use wildcard ports, since bind is not
+ * guaranteed to succeed on the test runner. */
+#if 0
     /* Address wildcard, IPv6 disabled */
-    void *sb = zmq_socket (ctx, ZMQ_REP);
+    sb = zmq_socket (ctx, ZMQ_REP);
     assert (sb);
-    void *sc = zmq_socket (ctx, ZMQ_REQ);
+    sc = zmq_socket (ctx, ZMQ_REQ);
     assert (sc);
 
-    int rc = zmq_bind (sb, "tcp://*:5555");
+    rc = zmq_bind (sb, "tcp://*:5555");
     assert (rc == 0);
 
     char bindEndpoint[256];
@@ -105,6 +114,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_close (sb);
     assert (rc == 0);
+#endif
 
     /* Port wildcard, IPv4 address, IPv6 disabled */
     sb = zmq_socket (ctx, ZMQ_REP);
@@ -115,7 +125,6 @@ int main (void)
     rc = zmq_bind (sb, "tcp://127.0.0.1:*");
     assert (rc == 0);
 
-    char endpoint[256];
     endpoint_len = sizeof (endpoint);
     memset(endpoint, 0, endpoint_len);
     rc = zmq_getsockopt (sb, ZMQ_LAST_ENDPOINT, endpoint, &endpoint_len);
@@ -206,6 +215,9 @@ int main (void)
         assert (rc == 0);
     }
 
+/* Disable all tests that don't use wildcard ports, since bind is not
+ * guaranteed to succeed on the test runner. */
+#if 0
     /* No wildcard, IPv4 address, IPv6 disabled */
     sb = zmq_socket (ctx, ZMQ_REP);
     assert (sb);
@@ -286,6 +298,7 @@ int main (void)
         rc = zmq_close (sb);
         assert (rc == 0);
     }
+#endif
 
     rc = zmq_ctx_term (ctx);
     assert (rc == 0);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_mandatory_hwm.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_router_mandatory_hwm.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_router_mandatory_hwm.cpp
@@ -41,6 +41,9 @@ int main (void)
     int rc;
     if (TRACE_ENABLED) fprintf(stderr, "Staring router mandatory HWM test ...\n");
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     void *router = zmq_socket (ctx, ZMQ_ROUTER);
@@ -57,7 +60,9 @@ int main (void)
     rc = zmq_setsockopt (router, ZMQ_LINGER, &linger, sizeof (linger));
     assert (rc == 0);
 
-    rc = zmq_bind (router, "tcp://127.0.0.1:5560");
+    rc = zmq_bind (router, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     //  Create dealer called "X" and connect it to our router, configure HWM
@@ -69,7 +74,7 @@ int main (void)
     rc = zmq_setsockopt (dealer, ZMQ_RCVHWM, &rcvhwm, sizeof (rcvhwm));
     assert (rc == 0);
 
-    rc = zmq_connect (dealer, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (dealer, my_endpoint);
     assert (rc == 0);
 
     //  Get message from dealer to know when connection is ready
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_req_relaxed.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_req_relaxed.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_req_relaxed.cpp
@@ -57,6 +57,9 @@ static void bounce (void *socket)
 int main (void)
 {
     setup_test_environment ();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
@@ -70,7 +73,9 @@ int main (void)
     rc = zmq_setsockopt (req, ZMQ_REQ_CORRELATE, &enabled, sizeof (int));
     assert (rc == 0);
 
-    rc = zmq_bind (req, "tcp://127.0.0.1:5555");
+    rc = zmq_bind (req, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (req, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     const size_t services = 5;
@@ -83,7 +88,7 @@ int main (void)
         rc = zmq_setsockopt (rep [peer], ZMQ_RCVTIMEO, &timeout, sizeof (int));
         assert (rc == 0);
 
-        rc = zmq_connect (rep [peer], "tcp://localhost:5555");
+        rc = zmq_connect (rep [peer], my_endpoint);
         assert (rc == 0);
     }
     //  We have to give the connects time to finish otherwise the requests
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_rep.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_spec_rep.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_rep.cpp
@@ -30,7 +30,8 @@
 #include "testutil.hpp"
 
 const char *bind_address = 0;
-const char *connect_address = 0;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 void test_fair_queue_in (void *ctx)
 {
@@ -43,6 +44,9 @@ void test_fair_queue_in (void *ctx)
 
     rc = zmq_bind (rep, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (rep, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *reqs [services];
@@ -106,6 +110,9 @@ void test_envelope (void *ctx)
 
     int rc = zmq_bind (rep, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (rep, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
     assert (dealer);
@@ -138,12 +145,10 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
-    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:5555" };
-    const char *connects [] = { "inproc://a", "tcp://localhost:5555" };
+    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:*" };
 
     for (int transport = 0; transport < 2; ++transport) {
         bind_address = binds [transport];
-        connect_address = connects [transport];
 
         // SHALL receive incoming messages from its peers using a fair-queuing
         // strategy.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_pair_tcp.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_pair_tcp.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_pair_tcp.cpp
@@ -32,17 +32,22 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     void *sb = zmq_socket (ctx, ZMQ_PAIR);
     assert (sb);
-    int rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (sb, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (sb, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     void *sc = zmq_socket (ctx, ZMQ_PAIR);
     assert (sc);
-    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (sc, my_endpoint);
     assert (rc == 0);
     
     bounce (sb, sc);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_stream.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream.cpp
@@ -53,10 +53,14 @@ static zmtp_greeting_t
                  { 0 }
     };
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
 static void
 test_stream_to_dealer (void)
 {
     int rc;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     //  Set up our context and sockets
     void *ctx = zmq_ctx_new ();
@@ -72,15 +76,18 @@ test_stream_to_dealer (void)
     int enabled = 1;
     rc = zmq_setsockopt (stream, ZMQ_STREAM_NOTIFY, &enabled, sizeof (enabled));
     assert (rc == 0);
-    rc = zmq_bind (stream, "tcp://127.0.0.1:5556");
+    rc = zmq_bind (stream, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (stream, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
+
     //  We'll be using this socket as the other peer
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
     assert (dealer);
     rc = zmq_setsockopt (dealer, ZMQ_LINGER, &zero, sizeof (zero));
     assert (rc == 0);
-    rc = zmq_connect (dealer, "tcp://localhost:5556");
+    rc = zmq_connect (dealer, my_endpoint);
 
     //  Send a message on the dealer socket
     rc = zmq_send (dealer, "Hello", 5, 0);
@@ -232,23 +239,27 @@ static void
 test_stream_to_stream (void)
 {
     int rc;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     //  Set-up our context and sockets
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     void *server = zmq_socket (ctx, ZMQ_STREAM);
     assert (server);
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
     int enabled = 1;
     rc = zmq_setsockopt (server, ZMQ_STREAM_NOTIFY, &enabled, sizeof (enabled));
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9070");
-    assert (rc == 0);
 
     void *client = zmq_socket (ctx, ZMQ_STREAM);
     assert (client);
     rc = zmq_setsockopt (client, ZMQ_STREAM_NOTIFY, &enabled, sizeof (enabled));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9070");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     uint8_t id [256];
     size_t id_size = 256;
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_last_endpoint.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_last_endpoint.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_last_endpoint.cpp
@@ -29,6 +29,7 @@
 
 #include "testutil.hpp"
 
+#if 0
 static void do_bind_and_verify (void *s, const char *endpoint)
 {
     int rc = zmq_bind (s, endpoint);
@@ -38,6 +39,7 @@ static void do_bind_and_verify (void *s,
     rc = zmq_getsockopt (s, ZMQ_LAST_ENDPOINT, reported, &size);
     assert (rc == 0 && strcmp (reported, endpoint) == 0);
 }
+#endif
 
 int main (void)
 {
@@ -52,8 +54,12 @@ int main (void)
     int rc = zmq_setsockopt (sb, ZMQ_LINGER, &val, sizeof (val));
     assert (rc == 0);
 
+/* Disable all tests that don't use wildcard ports, since bind is not
+ * guaranteed to succeed on the test runner. */
+#if 0
     do_bind_and_verify (sb, "tcp://127.0.0.1:5560");
     do_bind_and_verify (sb, "tcp://127.0.0.1:5561");
+#endif
 
     rc = zmq_close (sb);
     assert (rc == 0);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_sub_forward.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_sub_forward.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_sub_forward.cpp
@@ -32,29 +32,38 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char endpoint1[MAX_SOCKET_STRING];
+    char endpoint2[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     //  First, create an intermediate device
     void *xpub = zmq_socket (ctx, ZMQ_XPUB);
     assert (xpub);
-    int rc = zmq_bind (xpub, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (xpub, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (xpub, ZMQ_LAST_ENDPOINT, endpoint1, &len);
     assert (rc == 0);
     void *xsub = zmq_socket (ctx, ZMQ_XSUB);
     assert (xsub);
-    rc = zmq_bind (xsub, "tcp://127.0.0.1:5561");
+    rc = zmq_bind (xsub, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (xsub, ZMQ_LAST_ENDPOINT, endpoint2, &len);
     assert (rc == 0);
 
     //  Create a publisher
     void *pub = zmq_socket (ctx, ZMQ_PUB);
     assert (pub);
-    rc = zmq_connect (pub, "tcp://127.0.0.1:5561");
+    rc = zmq_connect (pub, endpoint2);
     assert (rc == 0);
 
     //  Create a subscriber
     void *sub = zmq_socket (ctx, ZMQ_SUB);
     assert (sub);
-    rc = zmq_connect (sub, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (sub, endpoint1);
     assert (rc == 0);
 
     //  Subscribe for all messages.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_tcp.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_reqrep_tcp.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_tcp.cpp
@@ -32,17 +32,22 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     void *sb = zmq_socket (ctx, ZMQ_REP);
     assert (sb);
-    int rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (sb, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (sb, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     void *sc = zmq_socket (ctx, ZMQ_REQ);
     assert (sc);
-    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (sc, my_endpoint);
     assert (rc == 0);
     
     bounce (sb, sc);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_metadata.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_metadata.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_metadata.cpp
@@ -79,6 +79,9 @@ zap_handler (void *handler)
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
@@ -97,9 +100,11 @@ int main (void)
     assert (client);
     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, "DOMAIN", 6);
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9001");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:9001");
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
 
     s_send (client, "This is a message");
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_term_endpoint.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_term_endpoint.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_term_endpoint.cpp
@@ -39,7 +39,9 @@ int main (void)
     int rc;
     char buf[BUF_SIZE];
     size_t buf_size;
+#if 0
     const char *ep = "tcp://127.0.0.1:5560";
+#endif
     const char *ep_wc_tcp = "tcp://127.0.0.1:*";
 #if !defined ZMQ_HAVE_WINDOWS && !defined ZMQ_HAVE_OPENVMS
     const char *ep_wc_ipc = "ipc://*";
@@ -51,11 +53,16 @@ int main (void)
     //  Create infrastructure.
     void *ctx = zmq_ctx_new ();
     assert (ctx);
-    void *push = zmq_socket (ctx, ZMQ_PUSH);
+    void *push, *pull;
+
+/* Disable all tests that don't use wildcard ports, since bind is not
+ * guaranteed to succeed on the test runner. */
+#if 0
+    *push = zmq_socket (ctx, ZMQ_PUSH);
     assert (push);
     rc = zmq_bind (push, ep);
     assert (rc == 0);
-    void *pull = zmq_socket (ctx, ZMQ_PULL);
+    *pull = zmq_socket (ctx, ZMQ_PULL);
     assert (pull);
     rc = zmq_connect (pull, ep);
     assert (rc == 0);
@@ -121,6 +128,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_ctx_term (ctx);
     assert (rc == 0);
+#endif
 
     //  Create infrastructure (wild-card binding)
     ctx = zmq_ctx_new ();
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_connect_rid.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_connect_rid.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_connect_rid.cpp
@@ -29,15 +29,18 @@
 
 #include "testutil.hpp"
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
 
 void test_stream_2_stream(){
     void *rbind, *rconn1;
     int ret;
     char buff[256];
     char msg[] = "hi 1";
-    const char *bindip = "tcp://127.0.0.1:5556";
+    const char *bindip = "tcp://127.0.0.1:*";
     int disabled = 0;
     int zero = 0;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
 
     //  Set up listener STREAM.
@@ -49,6 +52,8 @@ void test_stream_2_stream(){
     assert (0 == ret);
     ret = zmq_bind (rbind, bindip);
     assert(0 == ret);
+    ret = zmq_getsockopt (rbind, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (0 == ret);
 
     //  Set up connection stream.
     rconn1 = zmq_socket (ctx, ZMQ_STREAM);
@@ -59,7 +64,7 @@ void test_stream_2_stream(){
     //  Do the connection.
     ret = zmq_setsockopt (rconn1, ZMQ_CONNECT_RID, "conn1", 6);
     assert (0 == ret);
-    ret = zmq_connect (rconn1, bindip);
+    ret = zmq_connect (rconn1, my_endpoint);
 
 /*  Uncomment to test assert on duplicate rid.
     //  Test duplicate connect attempt.
@@ -83,7 +88,7 @@ void test_stream_2_stream(){
     assert ('h' == buff[128]);
 
     // Handle close of the socket.
-    ret = zmq_unbind (rbind, bindip);
+    ret = zmq_unbind (rbind, my_endpoint);
     assert(0 == ret);
     ret = zmq_close (rbind);
     assert(0 == ret);
@@ -98,8 +103,10 @@ void test_router_2_router(bool named){
     int ret;
     char buff[256];
     char msg[] = "hi 1";
-    const char *bindip = "tcp://127.0.0.1:5556";
+    const char *bindip = "tcp://127.0.0.1:*";
     int zero = 0;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
 
     //  Create bind socket.
@@ -109,6 +116,8 @@ void test_router_2_router(bool named){
     assert (0 == ret);
     ret = zmq_bind (rbind, bindip);
     assert (0 == ret);
+    ret = zmq_getsockopt (rbind, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (0 == ret);
 
     //  Create connection socket.
     rconn1 = zmq_socket (ctx, ZMQ_ROUTER);
@@ -125,7 +134,7 @@ void test_router_2_router(bool named){
     //  Make call to connect using a connect_rid.
     ret = zmq_setsockopt (rconn1, ZMQ_CONNECT_RID, "conn1", 6);
     assert (0 == ret);
-    ret = zmq_connect (rconn1, bindip);
+    ret = zmq_connect (rconn1, my_endpoint);
     assert (0 == ret);
 /*  Uncomment to test assert on duplicate rid
     //  Test duplicate connect attempt.
@@ -169,7 +178,7 @@ void test_router_2_router(bool named){
     ret = zmq_recv (rconn1, buff+128, 128, 0);
     assert (3 == ret && 'o' == buff[128]);
 
-    ret = zmq_unbind (rbind, bindip);
+    ret = zmq_unbind (rbind, my_endpoint);
     assert(0 == ret);
     ret = zmq_close (rbind);
     assert(0 == ret);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_monitor.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_monitor.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_monitor.cpp
@@ -68,6 +68,9 @@ int main (void)
 {
     setup_test_environment();
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     
@@ -101,9 +104,11 @@ int main (void)
     assert (rc == 0);
     
     //  Now do a basic ping test
-    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:9998");
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     bounce (server, client);
 
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_device.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_reqrep_device.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_device.cpp
@@ -32,29 +32,38 @@
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char endpoint1[MAX_SOCKET_STRING];
+    char endpoint2[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     //  Create a req/rep device.
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
     assert (dealer);
-    int rc = zmq_bind (dealer, "tcp://127.0.0.1:5560");
+    int rc = zmq_bind (dealer, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (dealer, ZMQ_LAST_ENDPOINT, endpoint1, &len);
     assert (rc == 0);
     void *router = zmq_socket (ctx, ZMQ_ROUTER);
     assert (router);
-    rc = zmq_bind (router, "tcp://127.0.0.1:5561");
+    rc = zmq_bind (router, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (router, ZMQ_LAST_ENDPOINT, endpoint2, &len);
     assert (rc == 0);
 
     //  Create a worker.
     void *rep = zmq_socket (ctx, ZMQ_REP);
     assert (rep);
-    rc = zmq_connect (rep, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (rep, endpoint1);
     assert (rc == 0);
 
     //  Create a client.
     void *req = zmq_socket (ctx, ZMQ_REQ);
     assert (req);
-    rc = zmq_connect (req, "tcp://127.0.0.1:5561");
+    rc = zmq_connect (req, endpoint2);
     assert (rc == 0);
 
     //  Send a request.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_shutdown_stress.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_shutdown_stress.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_shutdown_stress.cpp
@@ -31,17 +31,25 @@
 
 #define THREAD_COUNT 100
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
+struct thread_data {
+    void *s;
+    char endpoint[MAX_SOCKET_STRING];
+};
+
 extern "C"
 {
-    static void worker (void *s)
+    static void worker (void *data)
     {
         int rc;
+        struct thread_data *tdata = (struct thread_data *)data;
 
-        rc = zmq_connect (s, "tcp://127.0.0.1:5560");
+        rc = zmq_connect (tdata->s, tdata->endpoint);
         assert (rc == 0);
 
         //  Start closing the socket while the connecting process is underway.
-        rc = zmq_close (s);
+        rc = zmq_close (tdata->s);
         assert (rc == 0);
     }
 }
@@ -50,7 +58,6 @@ int main (void)
 {
     setup_test_environment();
     void *s1;
-    void *s2;
     int i;
     int j;
     int rc;
@@ -66,13 +73,21 @@ int main (void)
         s1 = zmq_socket (ctx, ZMQ_PUB);
         assert (s1);
 
-        rc = zmq_bind (s1, "tcp://127.0.0.1:5560");
+        rc = zmq_bind (s1, "tcp://127.0.0.1:*");
+        assert (rc == 0);
+        size_t len = MAX_SOCKET_STRING;
+        struct thread_data *tdata;
+        char my_endpoint[MAX_SOCKET_STRING];
+        rc = zmq_getsockopt (s1, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
         assert (rc == 0);
 
         for (i = 0; i != THREAD_COUNT; i++) {
-            s2 = zmq_socket (ctx, ZMQ_SUB);
-            assert (s2);
-            threads [i] = zmq_threadstart(&worker, s2);
+            /* Memory leak, but we don't care. */
+            tdata = (struct thread_data *) malloc(sizeof(struct thread_data));
+            strncpy(tdata->endpoint, my_endpoint, MAX_SOCKET_STRING);
+            tdata->s = zmq_socket (ctx, ZMQ_SUB);
+            assert (tdata->s);
+            threads [i] = zmq_threadstart(&worker, tdata);
         }
 
         for (i = 0; i != THREAD_COUNT; i++) {
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_system.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_system.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_system.cpp
@@ -72,7 +72,7 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
-    if (zmq_bind (dealer, "tcp://127.0.0.1:5670") == -1) {
+    if (zmq_bind (dealer, "tcp://127.0.0.1:*") == -1) {
         printf ("E: Cannot find 127.0.0.1 -- your system does not have local\n");
         printf ("E: networking. Please fix this before running libzmq checks.\n");
         return -1;
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_req.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_spec_req.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_req.cpp
@@ -30,7 +30,8 @@
 #include "testutil.hpp"
 
 const char *bind_address = 0;
-const char *connect_address = 0;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 void test_round_robin_out (void *ctx)
 {
@@ -39,6 +40,9 @@ void test_round_robin_out (void *ctx)
 
     int rc = zmq_bind (req, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (req, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *rep [services];
@@ -84,6 +88,9 @@ void test_req_only_listens_to_current_pe
 
     rc = zmq_bind (req, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (req, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 3;
     void *router [services];
@@ -148,6 +155,9 @@ void test_req_message_format (void *ctx)
 
     int rc = zmq_bind (req, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (req, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     rc = zmq_connect (router, connect_address);
     assert (rc == 0);
@@ -223,12 +233,10 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
-    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:5555" };
-    const char *connects [] = { "inproc://a", "tcp://localhost:5555" };
+    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:*" };
 
     for (int transport = 0; transport < 2; transport++) {
         bind_address = binds [transport];
-        connect_address = connects [transport];
 
         // SHALL route outgoing messages to connected peers using a round-robin
         // strategy.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_ipc.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_reqrep_ipc.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_reqrep_ipc.cpp
@@ -32,17 +32,21 @@
 int main (void)
 {
     setup_test_environment();
+    char my_endpoint[256];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     void *sb = zmq_socket (ctx, ZMQ_REP);
     assert (sb);
-    int rc = zmq_bind (sb, "ipc:///tmp/tester");
+    int rc = zmq_bind (sb, "ipc://*");
+    assert (rc == 0);
+    size_t len = sizeof(my_endpoint);
+    rc = zmq_getsockopt (sb, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     void *sc = zmq_socket (ctx, ZMQ_REQ);
     assert (sc);
-    rc = zmq_connect (sc, "ipc:///tmp/tester");
+    rc = zmq_connect (sc, my_endpoint);
     assert (rc == 0);
     
     bounce (sb, sc);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_pair_ipc.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_pair_ipc.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_pair_ipc.cpp
@@ -32,17 +32,21 @@
 int main (void)
 {
     setup_test_environment();
+    char my_endpoint[256];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
     void *sb = zmq_socket (ctx, ZMQ_PAIR);
     assert (sb);
-    int rc = zmq_bind (sb, "ipc:///tmp/tester");
+    int rc = zmq_bind (sb, "ipc://*");
+    assert (rc == 0);
+    size_t len = sizeof(my_endpoint);
+    rc = zmq_getsockopt(sb, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     void *sc = zmq_socket (ctx, ZMQ_PAIR);
     assert (sc);
-    rc = zmq_connect (sc, "ipc:///tmp/tester");
+    rc = zmq_connect (sc, my_endpoint);
     assert (rc == 0);
     
     bounce (sb, sc);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_connect_resolve.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_connect_resolve.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_connect_resolve.cpp
@@ -38,11 +38,16 @@ int main (void)
     void *sock = zmq_socket (ctx, ZMQ_PUB);
     assert (sock);
 
+    int rc;
+/* Disable all tests that don't use wildcard ports, since bind is not
+ * guaranteed to succeed on the test runner. */
+#if 0
     int rc = zmq_connect (sock, "tcp://localhost:1234");
     assert (rc == 0);
 
     rc = zmq_connect (sock, "tcp://[::1]:1234");
     assert (rc == 0);
+#endif
 
     rc = zmq_connect (sock, "tcp://localhost:invalid");
     assert (rc == -1);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy_terminate.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_proxy_terminate.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy_terminate.cpp
@@ -34,21 +34,38 @@
 // but there is no pull on the other side, previously the proxy blocks
 // in writing to the backend, preventing the proxy from terminating
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
+struct thread_data {
+    void *ctx;
+    char my_endpoint[MAX_SOCKET_STRING];
+    pthread_cond_t cond;
+    pthread_mutex_t mutex;
+};
+
 void
-server_task (void *ctx)
+server_task (void *data)
 {
+    struct thread_data *tdata = (struct thread_data *)data;
+    void *ctx = tdata->ctx;
+    size_t len = MAX_SOCKET_STRING;
     // Frontend socket talks to main process
     void *frontend = zmq_socket (ctx, ZMQ_SUB);
     assert (frontend);
     int rc = zmq_setsockopt (frontend, ZMQ_SUBSCRIBE, "", 0);
     assert (rc == 0);
-    rc = zmq_bind (frontend, "tcp://127.0.0.1:15564");
+    rc = zmq_bind (frontend, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (frontend, ZMQ_LAST_ENDPOINT, tdata->my_endpoint, &len);
     assert (rc == 0);
+    pthread_mutex_lock(&tdata->mutex);
+    pthread_cond_signal(&tdata->cond);
+    pthread_mutex_unlock(&tdata->mutex);
 
     // Nice socket which is never read
     void *backend = zmq_socket (ctx, ZMQ_PUSH);
     assert (backend);
-    rc = zmq_bind (backend, "tcp://127.0.0.1:15563");
+    rc = zmq_bind (backend, "tcp://127.0.0.1:*");
     assert (rc == 0);
 
     // Control socket receives terminate command from main over inproc
@@ -79,21 +96,29 @@ int main (void)
 {
     setup_test_environment ();
 
+    struct thread_data tdata;
     void *ctx = zmq_ctx_new ();
     assert (ctx);
+    tdata.ctx = ctx;
+
+    pthread_cond_init(&tdata.cond, NULL);
+    pthread_mutex_init(&tdata.mutex, NULL);
+    pthread_mutex_lock(&tdata.mutex);
+
     // Control socket receives terminate command from main over inproc
     void *control = zmq_socket (ctx, ZMQ_PUB);
     assert (control);
     int rc = zmq_bind (control, "inproc://control");
     assert (rc == 0);
 
-    void *thread = zmq_threadstart(&server_task, ctx);
+    void *thread = zmq_threadstart(&server_task, &tdata);
+    pthread_cond_wait(&tdata.cond, &tdata.mutex);
     msleep (500); // Run for 500 ms
 
     // Start a secondary publisher which writes data to the SUB-PUSH server socket
     void *publisher = zmq_socket (ctx, ZMQ_PUB);
     assert (publisher);
-    rc = zmq_connect (publisher, "tcp://127.0.0.1:15564");
+    rc = zmq_connect (publisher, tdata.my_endpoint);
     assert (rc == 0);
 
     msleep (SETTLE_TIME);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_empty.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_stream_empty.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_empty.cpp
@@ -31,6 +31,9 @@
 
 int main (void) {
     setup_test_environment ();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
     
@@ -39,9 +42,11 @@ int main (void) {
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
     assert (dealer);
     
-    int rc = zmq_bind (stream, "tcp://127.0.0.1:5555");
+    int rc = zmq_bind (stream, "tcp://127.0.0.1:*");
     assert (rc >= 0);
-    rc = zmq_connect (dealer, "tcp://127.0.0.1:5555");
+    rc = zmq_getsockopt (stream, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+    rc = zmq_connect (dealer, my_endpoint);
     assert (rc >= 0);
     zmq_send (dealer, "", 0, 0);
     
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_disconnect.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_stream_disconnect.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_disconnect.cpp
@@ -65,6 +65,9 @@ int main(int, char**)
 {
     setup_test_environment();
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *context = zmq_ctx_new ();
     void *sockets [2];
     int rc = 0;
@@ -73,13 +76,16 @@ int main(int, char**)
     int enabled = 1;
     rc = zmq_setsockopt (sockets [SERVER], ZMQ_STREAM_NOTIFY, &enabled, sizeof (enabled));
     assert (rc == 0);
-    rc = zmq_bind (sockets [SERVER], "tcp://0.0.0.0:6666");
+    rc = zmq_bind (sockets [SERVER], "tcp://0.0.0.0:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (sockets [SERVER], ZMQ_LAST_ENDPOINT, my_endpoint,
+                         &len);
     assert (rc == 0);
 
     sockets [CLIENT] = zmq_socket (context, ZMQ_STREAM);
     rc = zmq_setsockopt (sockets [CLIENT], ZMQ_STREAM_NOTIFY, &enabled, sizeof (enabled));
     assert (rc == 0);
-    rc = zmq_connect (sockets [CLIENT], "tcp://localhost:6666");
+    rc = zmq_connect (sockets [CLIENT], my_endpoint);
     assert (rc == 0);
 
     // wait for connect notification
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_pushpull.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_spec_pushpull.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_spec_pushpull.cpp
@@ -30,7 +30,8 @@
 #include "testutil.hpp"
 
 const char *bind_address = 0;
-const char *connect_address = 0;
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 void test_push_round_robin_out (void *ctx)
 {
@@ -39,6 +40,9 @@ void test_push_round_robin_out (void *ct
 
     int rc = zmq_bind (push, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (push, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *pulls [services];
@@ -85,6 +89,9 @@ void test_pull_fair_queue_in (void *ctx)
 
     int rc = zmq_bind (pull, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (pull, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     const size_t services = 5;
     void *pushs [services];
@@ -187,6 +194,9 @@ void test_destroy_queue_on_disconnect (v
 
     rc = zmq_bind (A, bind_address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (A, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     void *B = zmq_socket (ctx, ZMQ_PULL);
     assert (B);
@@ -264,12 +274,10 @@ int main (void)
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
-    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:5555" };
-    const char *connects [] = { "inproc://a", "tcp://localhost:5555" };
+    const char *binds [] = { "inproc://a", "tcp://127.0.0.1:*" };
 
     for (int transport = 0; transport < 2; ++transport) {
         bind_address = binds [transport];
-        connect_address = connects [transport];
 
         // PUSH: SHALL route outgoing messages to connected peers using a
         // round-robin strategy.
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_fork.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_fork.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_fork.cpp
@@ -29,7 +29,9 @@
 
 #include "testutil.hpp"
 
-const char *address = "tcp://127.0.0.1:6571";
+const char *address = "tcp://127.0.0.1:*";
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+char connect_address[MAX_SOCKET_STRING];
 
 #define NUM_MESSAGES 5
 
@@ -45,6 +47,9 @@ int main (void)
     assert (pull);
     int rc = zmq_bind (pull, address);
     assert (rc == 0);
+    size_t len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (pull, ZMQ_LAST_ENDPOINT, connect_address, &len);
+    assert (rc == 0);
 
     int pid = fork ();
     if (pid == 0) {
@@ -58,7 +63,7 @@ int main (void)
         assert (child_ctx);
         void *push = zmq_socket (child_ctx, ZMQ_PUSH);
         assert (push);
-        rc = zmq_connect (push, address);
+        rc = zmq_connect (push, connect_address);
         assert (rc == 0);
         int count;
         for (count = 0; count < NUM_MESSAGES; count++)
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_curve.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_security_curve.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_curve.cpp
@@ -135,7 +135,13 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (server, ZMQ_IDENTITY, "IDENT", 6);
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     //  Check CURVE security with valid credentials
@@ -147,7 +153,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, client_secret, 41);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     bounce (server, client);
     rc = zmq_close (client);
@@ -164,7 +170,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, client_secret, 41);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -179,7 +185,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, client_secret, 41);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -194,7 +200,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, garbage_key, 41);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -213,7 +219,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, bogus_secret, 41);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -222,7 +228,7 @@ int main (void)
     //  This must be caught by the curve_server class, not passed to ZAP
     client = zmq_socket (ctx, ZMQ_DEALER);
     assert (client);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_null.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_security_null.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_null.cpp
@@ -85,6 +85,9 @@ zap_handler (void *handler)
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
@@ -105,9 +108,11 @@ int main (void)
     assert (server);
     void *client = zmq_socket (ctx, ZMQ_DEALER);
     assert (client);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9000");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:9000");
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     bounce (server, client);
     close_zero_linger (client);
@@ -122,9 +127,12 @@ int main (void)
     assert (client);
     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, "WRONG", 5);
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9001");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:9001");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -137,9 +145,12 @@ int main (void)
     assert (client);
     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, "TEST", 4);
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9002");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:9002");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     bounce (server, client);
     close_zero_linger (client);
@@ -150,14 +161,22 @@ int main (void)
     assert (server);
     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, "WRONG", 5);
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9003");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+
+    len = MAX_SOCKET_STRING;
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     struct sockaddr_in ip4addr;
     int s;
 
+    unsigned short int port;
+    rc = sscanf(my_endpoint, "tcp://127.0.0.1:%hu", &port);
+    assert (rc == 1);
+
     ip4addr.sin_family = AF_INET;
-    ip4addr.sin_port = htons(9003);
+    ip4addr.sin_port = htons(port);
 #if defined (ZMQ_HAVE_WINDOWS) && (_WIN32_WINNT < 0x0600)
     ip4addr.sin_addr.s_addr = inet_addr ("127.0.0.1");
 #else
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_plain.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_security_plain.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_security_plain.cpp
@@ -97,6 +97,9 @@ zap_handler (void *ctx)
 int main (void)
 {
     setup_test_environment();
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
     void *ctx = zmq_ctx_new ();
     assert (ctx);
 
@@ -111,7 +114,9 @@ int main (void)
     int as_server = 1;
     rc = zmq_setsockopt (server, ZMQ_PLAIN_SERVER, &as_server, sizeof (int));
     assert (rc == 0);
-    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
+    rc = zmq_bind (server, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (server, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     char username [256];
@@ -126,7 +131,7 @@ int main (void)
     strcpy (password, "password");
     rc = zmq_setsockopt (client, ZMQ_PLAIN_PASSWORD, password, strlen (password));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     bounce (server, client);
     rc = zmq_close (client);
@@ -139,7 +144,7 @@ int main (void)
     as_server = 1;
     rc = zmq_setsockopt (client, ZMQ_PLAIN_SERVER, &as_server, sizeof (int));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -153,7 +158,7 @@ int main (void)
     assert (rc == 0);
     rc = zmq_setsockopt (client, ZMQ_PLAIN_PASSWORD, password, strlen (password));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://localhost:9998");
+    rc = zmq_connect (client, my_endpoint);
     assert (rc == 0);
     expect_bounce_fail (server, client);
     close_zero_linger (client);
@@ -162,8 +167,12 @@ int main (void)
     struct sockaddr_in ip4addr;
     int s;
 
+    unsigned short int port;
+    rc = sscanf(my_endpoint, "tcp://127.0.0.1:%hu", &port);
+    assert (rc == 1);
+
     ip4addr.sin_family = AF_INET;
-    ip4addr.sin_port = htons (9998);
+    ip4addr.sin_port = htons (port);
 #if defined (ZMQ_HAVE_WINDOWS) && (_WIN32_WINNT < 0x0600)
     ip4addr.sin_addr.s_addr = inet_addr ("127.0.0.1");
 #else
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_proxy.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_proxy.cpp
@@ -50,9 +50,20 @@
 #define QT_CLIENTS    3
 #define is_verbose 0
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
+struct thread_data {
+    void *ctx;
+    char my_endpoint[MAX_SOCKET_STRING];
+    pthread_cond_t cond;
+    pthread_mutex_t mutex;
+};
+
 static void
-client_task (void *ctx)
+client_task (void *data)
 {
+    struct thread_data *tdata = (struct thread_data *)data;
+    void *ctx = tdata->ctx;
     void *client = zmq_socket (ctx, ZMQ_DEALER);
     assert (client);
 
@@ -76,7 +87,7 @@ client_task (void *ctx)
     linger = 0;
     rc = zmq_setsockopt (client, ZMQ_LINGER, &linger, sizeof (linger));
     assert (rc == 0);
-    rc = zmq_connect (client, "tcp://127.0.0.1:5563");
+    rc = zmq_connect (client, tdata->my_endpoint);
     assert (rc == 0);
 
     zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 }, { control, 0, ZMQ_POLLIN, 0 } };
@@ -128,16 +139,25 @@ client_task (void *ctx)
 static void server_worker (void *ctx);
 
 void
-server_task (void *ctx)
+server_task (void *data)
 {
+    struct thread_data *tdata = (struct thread_data *)data;
+    void *ctx = tdata->ctx;
+    size_t len = MAX_SOCKET_STRING;
+
     // Frontend socket talks to clients over TCP
     void *frontend = zmq_socket (ctx, ZMQ_ROUTER);
     assert (frontend);
     int linger = 0;
     int rc = zmq_setsockopt (frontend, ZMQ_LINGER, &linger, sizeof (linger));
     assert (rc == 0);
-    rc = zmq_bind (frontend, "tcp://127.0.0.1:5563");
+    rc = zmq_bind (frontend, "tcp://127.0.0.1:*");
     assert (rc == 0);
+    rc = zmq_getsockopt (frontend, ZMQ_LAST_ENDPOINT, tdata->my_endpoint, &len);
+    assert (rc == 0);
+    pthread_mutex_lock(&tdata->mutex);
+    pthread_cond_signal(&tdata->cond);
+    pthread_mutex_unlock(&tdata->mutex);
 
     // Backend socket talks to workers over inproc
     void *backend = zmq_socket (ctx, ZMQ_DEALER);
@@ -261,10 +281,18 @@ int main (void)
     rc = zmq_bind (control, "inproc://control");
     assert (rc == 0);
 
+    struct thread_data tdata;
+    tdata.ctx = ctx;
+
+    pthread_cond_init(&tdata.cond, NULL);
+    pthread_mutex_init(&tdata.mutex, NULL);
+    pthread_mutex_lock(&tdata.mutex);
+
     void *threads [QT_CLIENTS + 1];
+    threads[QT_CLIENTS] = zmq_threadstart  (&server_task, &tdata);
+    pthread_cond_wait(&tdata.cond, &tdata.mutex);
     for (int i = 0; i < QT_CLIENTS; i++)
-        threads[i] = zmq_threadstart  (&client_task, ctx);
-    threads[QT_CLIENTS] = zmq_threadstart  (&server_task, ctx);
+        threads[i] = zmq_threadstart  (&client_task, &tdata);
     msleep (500); // Run for 500 ms then quit
 
     rc = zmq_send (control, "TERMINATE", 9, 0);
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_timeout.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_stream_timeout.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_stream_timeout.cpp
@@ -29,6 +29,8 @@
 
 #include "testutil.hpp"
 
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+
 //  Read one event off the monitor socket; return value and address
 //  by reference, if not null, and event number by value. Returns -1
 //  in case of error.
@@ -68,6 +70,8 @@ static void
 test_stream_handshake_timeout_accept (void)
 {
     int rc;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     //  Set up our context and sockets
     void *ctx = zmq_ctx_new ();
@@ -80,8 +84,6 @@ test_stream_handshake_timeout_accept (vo
     int zero = 0;
     rc = zmq_setsockopt (stream, ZMQ_LINGER, &zero, sizeof (zero));
     assert (rc == 0);
-    rc = zmq_connect (stream, "tcp://localhost:5557");
-    assert (rc == 0);
 
     //  We'll be using this socket to test TCP stream handshake timeout
     void *dealer = zmq_socket (ctx, ZMQ_DEALER);
@@ -119,7 +121,12 @@ test_stream_handshake_timeout_accept (vo
     assert (rc == 0);
 
     // bind dealer socket to accept connection from non-sending stream socket
-    rc = zmq_bind (dealer, "tcp://127.0.0.1:5557");
+    rc = zmq_bind (dealer, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (dealer, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+
+    rc = zmq_connect (stream, my_endpoint);
     assert (rc == 0);
 
     // we should get ZMQ_EVENT_ACCEPTED and then ZMQ_EVENT_DISCONNECTED
@@ -145,6 +152,8 @@ static void
 test_stream_handshake_timeout_connect (void)
 {
     int rc;
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     //  Set up our context and sockets
     void *ctx = zmq_ctx_new ();
@@ -157,7 +166,9 @@ test_stream_handshake_timeout_connect (v
     int zero = 0;
     rc = zmq_setsockopt (stream, ZMQ_LINGER, &zero, sizeof (zero));
     assert (rc == 0);
-    rc = zmq_bind (stream, "tcp://127.0.0.1:5556");
+    rc = zmq_bind (stream, "tcp://127.0.0.1:*");
+    assert (rc == 0);
+    rc = zmq_getsockopt (stream, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
     assert (rc == 0);
 
     //  We'll be using this socket to test TCP stream handshake timeout
@@ -196,7 +207,7 @@ test_stream_handshake_timeout_connect (v
     assert (rc == 0);
 
     // connect dealer socket to non-sending stream socket
-    rc = zmq_connect (dealer, "tcp://localhost:5556");
+    rc = zmq_connect (dealer, my_endpoint);
     assert (rc == 0);
 
     // we should get ZMQ_EVENT_CONNECTED and then ZMQ_EVENT_DISCONNECTED
Index: zeromq3-4.1.5+git20160811+2fc86bc/tests/test_diffserv.cpp
===================================================================
--- zeromq3-4.1.5+git20160811+2fc86bc.orig/tests/test_diffserv.cpp
+++ zeromq3-4.1.5+git20160811+2fc86bc/tests/test_diffserv.cpp
@@ -35,6 +35,9 @@ int main (void)
     int tos = 0x28;
     int o_tos;
     size_t tos_size = sizeof(tos);
+#define MAX_SOCKET_STRING sizeof("tcp://127.0.0.1:65536")
+    size_t len = MAX_SOCKET_STRING;
+    char my_endpoint[MAX_SOCKET_STRING];
 
     setup_test_environment();
     void *ctx = zmq_ctx_new ();
@@ -44,8 +47,11 @@ int main (void)
     assert (sb);
     rc = zmq_setsockopt (sb, ZMQ_TOS, &tos, tos_size);
     assert (rc == 0);
-    rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
+    rc = zmq_bind (sb, "tcp://127.0.0.1:*");
     assert (rc == 0);
+    rc = zmq_getsockopt (sb, ZMQ_LAST_ENDPOINT, my_endpoint, &len);
+    assert (rc == 0);
+
     rc = zmq_getsockopt (sb, ZMQ_TOS, &o_tos, &tos_size);
     assert (rc == 0);
     assert (o_tos == tos);
@@ -55,7 +61,7 @@ int main (void)
     tos = 0x58;
     rc = zmq_setsockopt (sc, ZMQ_TOS, &tos, tos_size);
     assert (rc == 0);
-    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
+    rc = zmq_connect (sc, my_endpoint);
     assert (rc == 0);
     rc = zmq_getsockopt (sc, ZMQ_TOS, &o_tos, &tos_size);
     assert (rc == 0);
